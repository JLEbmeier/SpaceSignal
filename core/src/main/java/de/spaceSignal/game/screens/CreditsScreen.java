package de.spaceSignal.game.screens;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.GlyphLayout;
import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator;
import com.badlogic.gdx.math.MathUtils;
import de.spaceSignal.game.Main;
import de.spaceSignal.game.util.Constants;
import de.spaceSignal.game.util.ScrollingBackground;

public class CreditsScreen extends BaseScreen {
    private BitmapFont titleFont;
    private BitmapFont creditsFont;
    private BitmapFont highlightedFont;
    private GlyphLayout layout;
    private ScrollingBackground background;
    private float scrollOffset = 0;
    private float animationTimer = 0;
    private int currentHighlightedIndex = -1;


    // Scroll-Geschwindigkeit anpassen
    private float scrollSpeed = 20f; // Viel langsamer als vorher (40f)

    private static final String[] credits = {
        "SPACE SIGNAL – THE VIBE CODING ODYSSEY",
        "",
        "Developed by xAI Team – Because humans are too slow",
        "",
        "Code Architect",
        "Herr Ebmeier – Master of 1s and 0s, Slayer of Bugs, Occasional Coffee-Spiller",
        "",
        "Graphics",
        "Recraft AI – Pixels lovingly ignored by humans, occasionally petting sprites",
        "",
        "Music",
        "TBD – Currently arguing with the bassline about existence",
        "",
        "Special Thanks",
        "The Community – Pressing buttons so enthusiastically it almost breaks the space-time continuum",
        "",
        "Easter Egg Finders",
        "Random Gamers Who Jumped Into Walls for Science",
        "",
        "AI Overlords",
        "Probably watching, occasionally laughing",
        "",
        "Unpaid Interns",
        "Time Travelers Who Sent Code From 2032 – Warning: May contain paradoxes",
        "",
        "Snack Contributors",
        "Pizza Deliveries That Survived the Coding Marathon – Heroic indeed",
        "",
        "Lost Socks",
        "In Memory of the Single Ones That Never Made it Home – RIP",
        "",
        "Pixel Dust Cleanup Crew",
        "Invisible but judging you silently",
        "",
        "Bug Witness Protection",
        "Shhh… don't tell them we found them",
        "",
        "Random Credits Generator",
        "Spitting absurdities while you scroll",
        "",
        "Quantum Particles",
        "Sometimes existing, sometimes not – like your lost lives in Bossrush Mode",
        "",
        "Coffee",
        "Forever fueling infinite loops and existential dread",
        "",
        "Time Attack Enthusiasts",
        "Who blinked at exactly the wrong moment and still won",
        "",
        "Bossrush Survivors",
        "Congratulations, you exist… barely",
        "",
        "Meta-Credits",
        "This game was made by a self-aware AI pretending to follow instructions",
        "",
        "In-Game Philosophers",
        "Discussing the moral implications of shooting pixelated aliens repeatedly",
        "",
        "Keyboard Enthusiasts",
        "Pressed ESC 37 times just to see this again",
        "",
        "Intergalactic Hamsters",
        "Running the code wheels, unpaid but cute",
        "",
        "Space Dust",
        "Because why not",
        "",
        "AI Ethics Committee",
        "Currently napping while chaos unfolds",
        "",
        "YOU – The Player",
        "For scrolling this far, questioning your life choices, and still loving pixel aliens",
        "",
        "WARNING: Credits may loop infinitely. Side effects include laughter, existential dread, mild obsession with pixels, and urge to restart the game repeatedly",
        "",
        "SPACE SIGNAL continues indefinitely…",
        "",
        "NOTE: These credits are generated by AI. Human oversight optional. Enjoy responsibly."
    };

    public CreditsScreen(Main game) {
        super(game);
        initializeFonts();
        layout = new GlyphLayout();
        initializeBackground();

        // Start mit erstem Element unten
        scrollOffset = Constants.SCREEN_HEIGHT;
    }

    private void initializeFonts() {
        try {
            FreeTypeFontGenerator generator = new FreeTypeFontGenerator(Gdx.files.internal("fonts/Orbitron-Regular.ttf"));
            FreeTypeFontGenerator.FreeTypeFontParameter param = new FreeTypeFontGenerator.FreeTypeFontParameter();
            float scaleFactor = Constants.SCREEN_WIDTH / 1280f;

            // Standard Title Font
            param.size = (int) (36 * scaleFactor); // Größer für bessere Lesbarkeit
            param.color = new Color(0.3f, 0.85f, 1f, 1f);
            param.borderColor = new Color(0.1f, 0.4f, 0.6f, 1f);
            param.borderWidth = 2f * scaleFactor;
            titleFont = generator.generateFont(param);

            // Standard Credits Font
            param.size = (int) (24 * scaleFactor); // Größer für bessere Lesbarkeit
            param.color = new Color(0.85f, 0.9f, 1f, 1f);
            param.borderColor = new Color(0.3f, 0.3f, 0.4f, 1f);
            param.borderWidth = 1.2f * scaleFactor;
            creditsFont = generator.generateFont(param);

            // Hervorgehobener Font für zentrierte Elemente
            param.size = (int) (28 * scaleFactor); // Größer für Hervorhebung
            param.color = new Color(1f, 1f, 1f, 1f);
            param.borderColor = new Color(0.2f, 0.6f, 1f, 1f);
            param.borderWidth = 2.5f * scaleFactor;
            highlightedFont = generator.generateFont(param);

            generator.dispose();
        } catch (Exception e) {
            Gdx.app.error("CreditsScreen", "Font error", e);
            titleFont = new BitmapFont();
            titleFont.getData().setScale(1.8f);
            creditsFont = new BitmapFont();
            creditsFont.getData().setScale(1.4f);
            highlightedFont = new BitmapFont();
            highlightedFont.getData().setScale(1.6f);
        }
    }

    private void initializeBackground() {
        try {
            String bgPath = "textures/background.png";
            if (Gdx.files.internal(bgPath).exists()) {
                background = new ScrollingBackground(new Texture(Gdx.files.internal(bgPath)));
                // Hintergrund-Scrolling wird automatisch langsamer sein,
                // da das Background-Update mit delta passiert
            }
        } catch (Exception e) {
            Gdx.app.error("CreditsScreen", "Failed to initialize background", e);
        }
    }

    @Override
    public void render(float delta) {
        Gdx.gl.glClearColor(0.01f, 0.01f, 0.05f, 1f);
        Gdx.gl.glClear(com.badlogic.gdx.graphics.GL20.GL_COLOR_BUFFER_BIT);

        update(delta);
        draw();
    }

    private void update(float delta) {
        if (background != null) background.update(delta);
        animationTimer += delta;

        // VIEL LANGSAMERES Scrollen nach oben
        scrollOffset -= scrollSpeed * delta;

        // Berechne die Gesamthöhe aller Credits
        float totalHeight = calculateTotalCreditsHeight();

        // Wenn alle Credits durchgescrollt sind, zurücksetzen
        if (scrollOffset < -totalHeight) {
            scrollOffset = Constants.SCREEN_HEIGHT;
        }

        // Pause-Taste hinzufügen (Leertaste)
        if (Gdx.input.isKeyJustPressed(Input.Keys.SPACE)) {
            scrollSpeed = scrollSpeed == 0 ? 20f : 0f; // Pause/Weiter
        }

        // Geschwindigkeit anpassen mit Pfeiltasten
        if (Gdx.input.isKeyJustPressed(Input.Keys.UP)) {
            scrollSpeed = Math.min(scrollSpeed + 5f, 50f);
        }
        if (Gdx.input.isKeyJustPressed(Input.Keys.DOWN)) {
            scrollSpeed = Math.max(scrollSpeed - 5f, 0f);
        }

        if (Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {
            game.setScreen(new MainMenuScreen(game));
            dispose();
        }
    }

    private float calculateTotalCreditsHeight() {
        float totalHeight = 0;
        float lineSpacing = 55 * (Constants.SCREEN_HEIGHT / 480f); // Mehr Abstand für bessere Lesbarkeit

        for (int i = 0; i < credits.length; i++) {
            totalHeight += lineSpacing;
        }

        // Extra Platz am Ende für besseren Übergang
        totalHeight += Constants.SCREEN_HEIGHT * 0.5f;

        return totalHeight;
    }

    private void draw() {
        game.batch.begin();

        // Hintergrund rendern
        if (background != null) {
            background.render(game.batch);
        }

        // Dunkles Overlay für bessere Lesbarkeit
        game.batch.setColor(0.02f, 0.02f, 0.08f, 0.5f); // Dunkler für besseren Kontrast
        game.batch.draw(createSolidTexture(), 0, 0, Constants.SCREEN_WIDTH, Constants.SCREEN_HEIGHT);
        game.batch.setColor(1, 1, 1, 1);

        // Credits Text zeichnen
        float y = scrollOffset;
        float centerX = Constants.SCREEN_WIDTH / 2f;
        float lineSpacing = 55 * (Constants.SCREEN_HEIGHT / 480f); // Mehr Abstand
        float centerY = Constants.SCREEN_HEIGHT / 2f;

        currentHighlightedIndex = -1;

        for (int i = 0; i < credits.length; i++) {
            String line = credits[i];
            if (line.isEmpty()) {
                y += lineSpacing;
                continue;
            }

            // Überspringe Elemente die außerhalb des sichtbaren Bereichs sind
            if (y < -100 || y > Constants.SCREEN_HEIGHT + 100) {
                y += lineSpacing;
                continue;
            }

            // Berechne Hervorhebungs-Faktor basierend auf Position zur Mitte
            float distanceFromCenter = Math.abs(y - centerY);
            float highlightFactor = 1f - MathUtils.clamp(distanceFromCenter / (centerY * 0.4f), 0f, 1f); // Engerer Bereich für Hervorhebung
            float alphaFade = 1f - MathUtils.clamp(distanceFromCenter / (centerY * 0.7f), 0f, 1f);

            // Bestimme ob dieses Element aktuell zentriert ist (enger Bereich)
            boolean isCentered = distanceFromCenter < 35f;
            if (isCentered && !line.isEmpty()) {
                currentHighlightedIndex = i;
            }

            // Schriftart und Farbe basierend auf Typ und Position
            boolean isTitle = line.equals("SPACE SIGNAL – THE VIBE CODING ODYSSEY");
            boolean isCategory = !line.isEmpty() && i > 0 && credits[i-1].isEmpty();

            BitmapFont font;
            Color textColor;

            if (isCentered && highlightFactor > 0.1f && !isTitle) {
                // Hervorgehobenes Element in der Mitte - LÄNGERE ANZEIGEZEIT
                font = highlightedFont;
                float pulse = (MathUtils.sin(animationTimer * 2f) * 0.2f + 0.8f) * highlightFactor; // Langsamerer Puls
                textColor = new Color(1f, 0.95f, 0.6f, alphaFade * pulse);

                // Stärkeres Hintergrund-Highlight für hervorgehobene Elemente
                layout.setText(font, line);
                float padding = 20f * highlightFactor;
                float highlightAlpha = alphaFade * 0.5f * highlightFactor;

                game.batch.setColor(0.1f, 0.3f, 0.6f, highlightAlpha);
                game.batch.draw(createSolidTexture(),
                    centerX - layout.width / 2 - padding,
                    y - layout.height / 2 - padding / 2,
                    layout.width + padding * 2,
                    layout.height + padding);
                game.batch.setColor(1, 1, 1, 1);
            } else if (isTitle) {
                font = titleFont;
                float pulse = MathUtils.sin(animationTimer * 1.5f) * 0.15f + 0.85f; // Langsamerer Puls
                textColor = new Color(0.3f + pulse * 0.3f, 0.85f + pulse * 0.15f, 1f, alphaFade);
            } else if (isCategory) {
                font = titleFont;
                textColor = new Color(0.5f, 0.8f, 1f, alphaFade * 0.9f);
            } else {
                font = creditsFont;
                textColor = new Color(0.85f, 0.9f, 1f, alphaFade * 0.85f);
            }

            // Text zeichnen
            layout.setText(font, line);
            float x = centerX - layout.width / 2;

            font.setColor(textColor);
            font.draw(game.batch, line, x, y);

            y += lineSpacing;
        }

        // Steuerungs-Info anzeigen
        creditsFont.setColor(1, 1, 1, 0.7f);
        String controls = "SPACE: Pause/Continue  UP/DOWN: Speed  ESC: Exit";
        layout.setText(creditsFont, controls);
        creditsFont.draw(game.batch, controls, Constants.SCREEN_WIDTH - layout.width - 10, 30);

        // Aktuelle Geschwindigkeit anzeigen
        String speedInfo = String.format("Speed: %.1f", scrollSpeed);
        layout.setText(creditsFont, speedInfo);
        creditsFont.draw(game.batch, speedInfo, 10, 30);

        game.batch.end();
    }

    // Hilfsmethode für einfarbige Textur (für Overlay)
    private Texture createSolidTexture() {
        Texture texture = new Texture(1, 1, com.badlogic.gdx.graphics.Pixmap.Format.RGBA8888);
        texture.setFilter(Texture.TextureFilter.Nearest, Texture.TextureFilter.Nearest);
        return texture;
    }

    @Override
    public void dispose() {
        if (titleFont != null) titleFont.dispose();
        if (creditsFont != null) creditsFont.dispose();
        if (highlightedFont != null) highlightedFont.dispose();
        if (background != null) background.dispose();
    }
}
